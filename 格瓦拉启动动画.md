1. 


# 格瓦拉启动动画

* 1.**观察格瓦拉的启动页动画 **

 不难发现，启动页到动画的过程是一个分层，虽然LaunchImage是一个完整的图片，但是动画效果明显可以看出，
 底部的背景是一层，格瓦拉LOGO是一层，动画白色的扩展是一层，小哥头像是一层。动画效果的出现就是对白色层
 的放大。

![png](Snip20160506_1.png)
``` objc
    //动画创建
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"transform.scale";
    animation.toValue = @8;
    animation.duration = 1.0;
    
    animation.fillMode = kCAFillModeForwards;
    animation.removedOnCompletion = NO;
    animation.timingFunction = UIViewAnimationCurveEaseInOut;
```

* **2. 实现过程**

 实现过程中，发现很多细节问题：
 如果将所有动画分层，就涉及到了对CALayer的动画，在添加层的过程中，
 一开始的思路是：白色背景是一个容器UIView，背景扩散的动画效果是一个新添加在容器上的CALayer，
 图片轮播的动画效果是一个UIImageView的图片数组动画

```objc
    NSMutableArray *imgArr = [NSMutableArray array];
    NSString *imgPrefix = @"icon_xg";
    for (NSInteger index = 1; index<= ImgCount; index++) {
        NSString *imgName = [NSString stringWithFormat:@"%@%ld",imgPrefix,index];
        UIImage *img = [UIImage imageNamed:imgName];
        [imgArr addObject:img];
    }
    self.AnimImgView = [[UIImageView alloc]init];
    [self.view addSubview:self.AnimImgView];
    [self.AnimImgView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.size.mas_equalTo(CGSizeMake(150, 150));
        make.center.mas_equalTo(self.AnimContainerView);
    }];
    
    self.AnimImgView.image = [UIImage imageNamed:@"icon_xg9"];
    self.AnimImgView.animationImages = imgArr;
    self.AnimImgView.animationDuration = 2;
    self.AnimImgView.animationRepeatCount = 1;
    [self.AnimImgView startAnimating];
}
```
  在实现的过程中碰到了一些问题:我的动画界面是一个控制器：IntroViewController，这个控制器为了界面布局的方便，
选择了使用xib，然后将ContainerView添加上去，再讲imgView添加到Container上，发现除了问题：因为需要对Container做动画，而动画效果是由一个layer实现的，这个layer是在后来才被加上去的，所以再盖上去的时候，imgView也变成了白色，将图标给盖住了。

* **结构优化调整**

 针对上面所描述出现的问题，其实已经需要将imgView放在控制器的view上面了，而不能讲imgView放在Container上，**其实这个想法并不是第一时间发现的我发现的**。在格瓦拉的动所以在后来实现的过程中，我显现属于imgView动画的其中一个图片:
 
![](icon_xg4_180x180_@2x.png)

  这个图片超出了Container的范围，所以，至此改变思路：**将imgView放在控制器的view上面**。这样子，就不会出现
新添加的layer覆盖了imgView的icon这种情况了。

* **问题总结**

 所以，如果一个view提前在xib中，放在了一个父控件View(Container)中，那么对父控件Container新添加的layer会将当前view覆盖。而如果是纯代码按顺序添加layer则不会。












